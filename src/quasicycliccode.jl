# Copyright (c) 2022 Eric Sabo
# All rights reserved.
#
# This source code is licensed under the BSD-style license found in the
# LICENSE file in the root directory of this source tree.

mutable struct QuasiCyclicCode <: AbstractQuasiCyclicCode
    F::Union{FqNmodFiniteField}
    n::Integer
    k::Integer
    d::Union{Integer, Missing}
    G::fq_nmod_mat
    Gorig::Union{fq_nmod_mat, Missing}
    H::fq_nmod_mat
    Horig::Union{fq_nmod_mat, Missing}
    Gstand::fq_nmod_mat
    Hstand::fq_nmod_mat
    weightenum::Union{WeightEnumerator, Missing}
    l::Int
    m::Int
    genvecs::Vector{fq_nmod_mat}
    circulants::Vector{fq_nmod_mat}
    Gcirc::fq_nmod_mat
    Hcirc::fq_nmod_mat
end

# """
#     QuasiCyclicCode(v::fq_nmod_mat, l::Int)

# Return the quasi-cyclic code of index `l` generated by right-bit shifts of size `l` of the
# generator vector `v`.
# """
# function QuasiCyclicCode(v::fq_nmod_mat, l::Int)
#     r, n = size(v)
#     (r != 1 && n != 1) && throw(ArgumentError("The input matrix must be a vector."))
#     if r != 1
#         r % l == 0 || throw(ArgumentError("Parameter l must divide the length of the vector."))
#         m = div(r, l)
#     else
#         n % l == 0 || throw(ArgumentError("Parameter l must divide the length of the vector."))
#         m = div(n, l)
#     end
#     F = base_ring(v)
#     G = zero_matrix(F, m, n)
#     for i in 1:m
#         r == 1 ? (G[i, :] = circshift(v, (i - 1) * l);) : (G[i, :] = transpose(circshift(v, (i - 1) * l));)
#     end
#     # display(G)
#     # println(" ")

#     circulants = Vector{fq_nmod_mat}()
#     Gcirc = zero_matrix(F, 1, 1)
#     for c in 1:l
#         C = zero_matrix(F, m, m)
#         for i in 1:m
#             C[:, i] = G[:, (i - 1) * l + c]
#         end
#         # display(C)
#         # println(" ")
#         isempty(circulants) ? (Gcirc = C;) : (Gcirc = hcat(Gcirc, C);)
#         push!(circulants, C)
#     end
#     # display(circulants)
#     # println(" ")
#     # display(Gcirc)

#     # rows of G may not be linearly independent, find true parameters and H
#     C = LinearCode(G)
#     return QuasiCyclicCode(C.F, C.n, C.k, missing, G, missing, C.H, missing, C.Gstand,
#         C.Hstand, missing, l, m, [v], circulants, Gcirc)
# end

"""
    QuasiCyclicCode(v::Vector{fq_nmod_mat}, l::Int, circgens::Bool, parity::Bool=false)

Return the quasi-cyclic code of index `l` generated by right-bit shifts of size `l` of the
generator vectors `v`. If `circgens` is `true`, the vectors are taken to be generators for
the circulant matrices instead of generator vectors for the code. If the optional paramater
`parity` is set to `true`, the input is used to construct the parity check matrix.

Note:
- If `circgens` is `false`, then the length of the code is `ncols(v[1])` and must be divisible by `l`.
- If `circgens` is `true`, then the length of the code is `ncols(v[1]) * l`. Circulant matrices are
  stacked in rows of length `l`, so `l` must divide `length(v)`.
- Use the other constructor for `circgens == false` and `length(v) == 1`.
"""
function QuasiCyclicCode(v::Vector{fq_nmod_mat}, l::Int, circgens::Bool, parity::Bool=false)
    F = base_ring(v[1])
    if circgens
        lenv = length(v)
        lenv >= 2 || throw(ArgumentError("Length of input vector must be at least two."))
        lenv % l == 0 || throw(ArgumentError("The length of the input vector must be divisible by l."))
        r, m = size(v[1])
        (r != 1 && m != 1) && throw(ArgumentError("The input matrices must be vectors."))
        m == 1 && (v[1] = transpose(v[1]); (r, m = size(v[1]));)
        n = m * l
        for i in 2:lenv
            F == base_ring(v[i]) || throw(ArgumentError("All inputs must be over the same base ring."))
            r2, m2 = size(v[i])
            (r2 != 1 && m2 != 1) && throw(ArgumentError("The input matrices must be vectors."))
            m2 == 1 && (v[i] = transpose(v[i]); (r2, m2 = size(v[i]));)
            m == m2 || throw(ArgumentError("The input vectors must all be the same length."))
        end

        G = zero_matrix(F, m, n)
        Gcirc = zero_matrix(F, 1, 1)
        circulants = Vector{fq_nmod_mat}()
        Gouter = zero_matrix(F, m, n)
        Gcircouter = zero_matrix(F, 1, 1)
        circulantsouter = Vector{fq_nmod_mat}()
        genvecs = Vector{fq_nmod_mat}()
        for k in 1:lenv
            C = zero_matrix(F, m, m)
            C[1, :] = v[k]
            for i in 2:m
                C[i, :] = circshift(v[k], i - 1)
            end
            isempty(circulants) ? (Gcirc = C;) : (Gcirc = hcat(Gcirc, C);)
            push!(circulants, C)

            for i in 1:m
                c = k % l
                c == 0 && (c = l;)
                G[:, (i - 1) * l + c] = C[:, i]
            end

            if k == lenv
                Gouter = vcat(Gouter, G)
                Gcircouter = vcat(Gcircouter, G)
                append!(circulantsouter, circulants)
                push!(genvecs, G[1, :])
            elseif k % l == 0
                iszero(Gouter) ? (Gouter = G;) : (Gouter = vcat(Gouter, G);)
                iszero(Gcircouter) ? (Gcircouter = Gcirc;) : (Gcircouter = vcat(Gcircouter, G);)
                append!(circulantsouter, circulants)
                push!(genvecs, G[1, :])
                G = zero_matrix(F, m, n)
                Gcirc = zero_matrix(F, 1, 1)
                circulants = Vector{fq_nmod_mat}()
            end
        end

        # rows of Gouter may not be linearly independent, find true parameters and H
        C = LinearCode(Gouter)
        # note the H here is transpose of the standard definition
        _, H = right_kernel(Gcirc)
        if parity
            return QuasiCyclicCode(C.F, C.n, C.n - C.k, missing, C.H, missing, Gouter, missing,
                C.Hstand, C.Gstand, missing, l, m, v, circulantsouter, Gcircouter, transpose(H))
        else
            return QuasiCyclicCode(C.F, C.n, C.k, missing, Gouter, missing, C.H, missing,
                C.Gstand, C.Hstand, missing, l, m, v, circulantsouter, tranpose(H), Gcircouter)
        end
    else
        r, n = size(v[1])
        (r != 1 && n != 1) && throw(ArgumentError("The input matrices must be vectors."))
        n == 1 && (v[1] = transpose(v[1]); (r, n = size(v[1]));)
        n % l == 0 || throw(ArgumentError("Parameter l must divide the length of the vector."))
        m = div(n, l)
        for i in 2:lenv
            F == base_ring(v[i]) || throw(ArgumentError("All vectors must be over the same base ring."))
            r2, n2 = size(v[i])
            (r2 != 1 && n2 != 1) && throw(ArgumentError("The input matrices must be vectors."))
            n2 == 1 && (v[i] = transpose(v[i]); (r2, n2 = size(v[i]));)
            n == n2 || throw(ArgumentError("The input vectors must all be the same length."))
        end
        
        Gouter = zero_matrix(F, m, n)
        Gcircouter = zero_matrix(F, 1, 1)
        circulantsouter = Vector{fq_nmod_mat}()
        for k in 1:lenv
            circulants = Vector{fq_nmod_mat}()
            G = zero_matrix(F, m, n)
            for i in 1:m
                G[i, :] = circshift(v[k], (i - 1) * l)
            end

            Gcirc = zero_matrix(F, 1, 1)
            for c in 1:l
                C = zero_matrix(F, m, m)
                for i in 1:m
                    C[:, i] = G[:, (i - 1) * l + c]
                end
                isempty(circulants) ? (Gcirc = C;) : (Gcirc = hcat(Gcirc, C);)
                push!(circulants, C)
            end
            iszero(Gouter) ? (Gouter = G;) : (Gouter = vcat(Gouter, G);)
            iszero(Gcircouter) ? (Gcircouter = Gcirc;) : (Gcircouter = vcat(Gcircouter, G);)
            append!(circulantsouter, circulants)
        end
        
        # rows of Gouter may not be linearly independent, find true parameters and H
        C = LinearCode(Gouter)
        # note the H here is transpose of the standard definition
        _, H = right_kernel(Gcirc)
        if parity
            return QuasiCyclicCode(C.F, C.n, C.n - C.k, missing, C.H, missing, Gouter, missing,
                C.Hstand, C.Gstand, missing, l, m, v, circulantsouter, Gcircouter, transpose(H))
        else
            return QuasiCyclicCode(C.F, C.n, C.k, missing, Gouter, missing, C.H, missing,
                C.Gstand, C.Hstand, missing, l, m, v, circulantsouter, tranpose(H), Gcircouter)
        end
    end
end

"""
    QuasiCyclicCode(v::fq_nmod_mat, l::Int, parity::Bool=false)

Return the quasi-cyclic code of index `l` generated by right-bit shifts of size `l` of the
generator vector `v`. If the optional paramater `parity` is set to `true`, the input is used
to construct the parity check matrix.
"""
function QuasiCyclicCode(v::fq_nmod_mat, l::Int, parity::Bool=false)
    return QuasiCyclicCode([v], l, false, parity)
end

"""
    QuasiCyclicCode(v::Vector{fq_nmod_poly}, n::Int, l::Int, parity::Bool=false)

Return the quasi-cyclic code of index `l` whose circulants are defined by the generator
polynomials `v`. If the optional paramater `parity` is set to `true`, the input is used
to construct the parity check matrix.
"""
function QuasiCyclicCode(v::Vector{fq_nmod_poly}, n::Int, l::Int, parity::Bool=false)
    # if g = x^10 + α^2*x^9 + x^8 + α*x^7 + x^3 + α^2*x^2 + x + α
    # g.coeffs = [α  1  α^2  1  0  0  0  α  1  α^2  1]
    genvecs = Vector{fq_nmod_mat}()
    F = base_ring(v[1])
    for g in v
        temp = zero_matrix(F, 1, n)
        coeffs = collect(coefficients(g))
        temp[1, 1:length(coeffs)] = coeffs
        push!(genvecs, temp)
    end
    return QuasiCyclicCode(genvecs, l, true, parity)
end

"""
    QuasiCyclicCode(v::Vector{AbstractCyclicCode}, l::Int, parity::Bool=false)

Return the quasi-cyclic code of index `l` whose circulants are determined by the cyclic
codes in `v`. If the optional paramater `parity` is set to `true`, the input is used to
construct the parity check matrix.
"""
function QuasiCyclicCode(v::Vector{AbstractCyclicCode}, l::Int, parity::Bool=false)
    genvecs = Vector{fq_nmod_mat}()
    for C in v
        push!(genvecs, C.G[1, :])
    end
    return QuasiCyclicCode(gences, l, true, parity)
end

"""
    index(C::AbstractQuasiCyclicCode)

Return the index of the quasi-cyclic code.
"""
index(C::AbstractQuasiCyclicCode) = C.l

"""
    generators(C::AbstractQuasiCyclicCode)

Return the generators of the quasi-cyclic code.
"""
generators(C::AbstractQuasiCyclicCode) = C.genvecs

"""
    circulants(C::AbstractQuasiCyclicCode)

Return the circulant matrices of the quasi-cyclic code.
"""
circulants(C::AbstractQuasiCyclicCode) = C.circulants

"""
    circulantgenerators(C::AbstractQuasiCyclicCode)

Return the generators of the circulant matrices of the quasi-cyclic code.
"""
function circulantgenerators(C::AbstractQuasiCyclicCode)
    circgenvecs = Vector{fq_nmod_mat}()
    for G in C.circulants
        push!(circgenvecs, G[1, :])
    end
    return circgenvecs
end

"""
    circulantgeneratorpolynomials(C::AbstractQuasiCyclicCode)

Return the generator polynomials of the circulant matrices of the quasi-cyclic code.
If the the length of the circulant generators and the order of the base ring are coprime,
the polynomials are returned over the splitting field.
"""
# TODO: Need to think about whether this is the behavior I want
function circulantgeneratorpolynomials(C::AbstractQuasiCyclicCode)
    circgenvecs = circulantgenerators(C)
    circgenpolys = Vector{fq_nmod_poly}()
    ordF = Int(order(C.F))
    (p, t), = factor(ordF)
    if gcd(C.m, p) == 1
        deg = ord(C.n, ordF)
        E, α = FiniteField(p, t * deg, "α")
    else
        E = C.F
    end
    R, _ = PolynomialRing(E, "x")
    for v in circgenvecs
        push!(circgenpolys, R([E(v[1, i]) for i in 1:C.m]))
    end
    return circgenpolys
end

"""
    circulantcycliccodes(C::AbstractQuasiCyclicCode)

Return the cyclic codes defined by the circulant matrices of the quasi-cyclic code.
"""
function circulantcycliccodes(C::AbstractQuasiCyclicCode)
    circgenpolys = circulantgeneratorpolynomials(C)
    circcyccodes = Vector{CyclicCode}()
    for g in circgenpolys
        push!(circcyccodes, CyclicCode(C.m, g))
    end
    return circcyccodes
end

function show(io::IO, C::AbstractQuasiCyclicCode)
    if ismissing(C.d)
        println(io, "[$(C.n), $(C.k)]_$(order(C.F)) quasi-cyclic code of index $(C.l).")
    else
        println(io, "[$(C.n), $(C.k), $(C.d)]_$(order(C.F)) quasi-cyclic code of index $(C.l).")
    end
    if get(io, :compact, true) && C.n <= 20
        println(io, "Generator matrix: $(C.k) × $(C.n)")
        for i in 1:C.k
            print(io, "\t")
            for j in 1:C.n
                if j != C.n
                    print(io, "$(C.G[i, j]) ")
                elseif j == C.n && i != C.k
                    println(io, "$(C.G[i, j])")
                else
                    print(io, "$(C.G[i, j])")
                end
            end
        end
        # if !ismissing(C.weightenum)
        #     println(io, "\nComplete weight enumerator:")
        #     print(io, "\t", C.weightenum.polynomial)
        # end
    end
end


# Expansion factor
# Weightmatrix=basematrix=protographmatrix
# Polynomial matrices
# Type

# Change comment on irregular
# QC codes are examples of protographs w/ weight matrix
# Return polys only over base field